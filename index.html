<html>

<head>
  <title>Binary Calculator</title>
</head>
<!--
    Simple calculator for binary numbers.
    Copyright (C) 2019 Oliver Lau <ola@ct.de>, Heise Medien GmbH & Co. KG

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<style type="text/css">
  * {
    margin: 0;
    padding: 0;
  }

  html,
  body {
    background-color: #e9e7de;
    font-family: 'Courier New', Courier, monospace;
    font-size: 12pt;
  }

  h1 {
    font-size: 18pt;
  }

  .app {
    padding: 5pt;
  }

  .container {
    margin: 5pt auto;
  }

  textarea {
    background-color: white;
    color: black;
    font-family: "Courier New", Courier, monospace;
    font-size: 12pt;
    padding: 4pt;
    width: 100%;
    height: 50pt;
  }
</style>
<script type="text/javascript">
  (function (window) {
    'use strict';
    let inEl = null;
    let outEl = null;
    let msgEl = null;
    let baseFormEl = null;
    let values = [];
    let ops = [];
    let base = localStorage.getItem('base') || 2;
    const Padding = (function (length) {
      let padding = '';
      for (let i = 0; i < length; ++i) {
        padding += '0';
      }
      return padding;
    })(512);

    Array.prototype.peek = function() { return this[this.length-1]; };

    class Token {
      constructor(type, value) {
        this._type = type;
        this._value = value;
      }

      get type() {
        return this._type;
      }

      get value() {
        return this._value;
      }

      set type(t) {
        this._type = t;
      }

      set value(v) {
        this._value = v;
      }

      get precedence() {
        return Token.Operator[this.value].prec;
      }

      get associativity() {
        return Token.Operator[this.value].assoc;
      }
    }

    Token.Type = (function(types) {
      let obj = {};
      for (let i in types) {
        obj[types[i]] = +i+1;
      }
      return obj;
    })(['Literal', 'Operator', 'Variable', 'LeftParenthesis', 'RightParenthesis']);

    Token.BasePrefix = {
      2: '0b',
      8: '0o',
      10: '',
      16: '0x',
    };

    Token.Types = [
      { regex: /^(&=|\^=|\/=|\^|\&|\||\+|\-|\*\*|\*|\/|%|<<|>>|<=|>=|<|>|=)/, type: Token.Type.Operator, name: 'operator' },
      { regex: /^(\()/, type: Token.Type.LeftParenthesis, name: 'left parenthesis' },
      { regex: /^(\))/, type: Token.Type.RightParenthesis, name: 'right parenthesis' },
      { regex: /^b([01]+)/, type: Token.Type.Literal, base: 2, name: 'binary' },
      { regex: /^o([0-7]+)/, type: Token.Type.Literal, base: 8, name: 'octal' },
      { regex: /^([0-9]+)/, type: Token.Type.Literal, base: 10, name: 'decimal' },
      { regex: /^x([0-9a-fA-F]+)/, type: Token.Type.Literal, base: 16, name: 'hexadecimal' },
      { regex: /^([a-zA-Z_]+)/, type: Token.Type.Variable, name: 'variable' },
    ];

    const LEFT = -1;
    const RIGHT = 1;

    // see https://en.cppreference.com/w/cpp/language/operator_precedence
    Token.Operator = {
      '-': {
        prec: -3,
        assoc: RIGHT,
      },
      '~': {
        prec: -3,
        assoc: RIGHT,
      },
      '*': {
        prec: -5,
        assoc: LEFT,
      },
      '/': {
        prec: -5,
        assoc: LEFT,
      },
      '%': {
        prec: -5,
        assoc: LEFT,
      },
      '+': {
        prec: -6,
        assoc: LEFT,
      },
      '-': {
        prec: -6,
        assoc: LEFT,
      },
      '<<': {
        prec: -7,
        assoc: LEFT,
      },
      '>>': {
        prec: -7,
        assoc: LEFT,
      },
      '<': {
        prec: -9,
        assoc: LEFT,
      },
      '>': {
        prec: -9,
        assoc: LEFT,
      },
      '<=': {
        prec: -9,
        assoc: LEFT,
      },
      '>=': {
        prec: -9,
        assoc: LEFT,
      },
      '&': {
        prec: -11,
        assoc: LEFT,
      },
      '^': {
        prec: -12,
        assoc: LEFT,
      },
      '|': {
        prec: -13,
        assoc: LEFT,
      },
      '=': {
        prec: -16,
        assoc: RIGHT,
      }
    };

    let tokenize = str => {
      let expr = str.replace(/\s+/g, '');
      let tokens = [];
      while (expr.length > 0) {
        let found = false;
        for (let i = 0; i < Token.Types.length && !found; ++i) {
          let t = Token.Types[i];
          let m = expr.match(t.regex);
          if (m && m.length > 0) {
            let symbol = m[1];
            let len = m[0].length;
            let value;
            switch (t.type) {
              case Token.Type.Literal:
                try {
                  value = BigInt(Token.BasePrefix[t.base] + symbol);
                }
                catch (e) {
                  console.error(e);
                }
                break;
              default:
                value = symbol;
                break;
            }
            tokens.push(new Token(t.type, value));
            expr = expr.substring(len);
            found = true;
          }
        }
        if (!found) {
          return {error: `invalid expression: ${str}`};
        }
      }
      return {tokens: tokens};
    }

    let shuntingYard = tokens => {
      let ops = [];
      let queue = [];
      for (const token of tokens) {
        switch (token.type) {
          case Token.Type.Literal:
          // fall-through
          case Token.Type.Variable:
            queue.push(token);
            break;
          case Token.Type.Operator:
            while (ops.peek() &&
              (ops.peek().type !== Token.Type.LeftParenthesis)
              &&
              (
                (ops.peek().precedence > token.precedence)
                ||
                (ops.peek().precedence === token.precedence && ops.peek().associativity === LEFT)
              )
            ) {
              queue.push(ops.pop());
            }
            ops.push(token);
            break;
          case Token.Type.LeftParenthesis:
            ops.push(token);
            break;
          case Token.Type.RightParenthesis:
            while (ops.peek() && ops.peek().type !== Token.Type.LeftParenthesis) {
              queue.push(ops.pop());
            }
            if (ops.peek().type === Token.Type.LeftParenthesis) {
              ops.pop();
            }
            break;
          default:
            break;
        }
      }
      while (ops.length > 0) {
        queue.push(ops.pop());
      }
      return queue;
    }

    let formulaChanged = event => {
      let result = tokenize(inEl.value);
      if (result.error) {
        msgEl.innerText = result.error;
        return;
      }
      else {
        msgEl.innerText = '';
      }
      if (result.tokens) {
        let tokens = shuntingYard(result.tokens);
        let s = [];
        for (const t of tokens) {
          if (t.type === Token.Type.Literal) {
            s.push(t);
          }
          else if (t.type === Token.Type.Variable) {
            s.push(t); // XXX
          }
          else {
            let o2 = s.pop();
            let o1 = s.pop();
            console.log(o2, o1);
            try {
              switch (t.value) {
                case '+':
                  s.push(new Token(Token.Type.Literal, o1.value + o2.value));
                  break;
                case '-':
                  s.push(new Token(Token.Type.Literal, o1.value - o2.value));
                  break;
                case '*':
                  s.push(new Token(Token.Type.Literal, o1.value * o2.value));
                  break;
                case '/':
                  s.push(new Token(Token.Type.Literal, o1.value / o2.value));
                  break;
                case '^':
                  s.push(new Token(Token.Type.Literal, o1.value ^ o2.value));
                  break;
                case '|':
                  s.push(new Token(Token.Type.Literal, o1.value | o2.value));
                  break;
                case '&':
                  s.push(new Token(Token.Type.Literal, o1.value & o2.value));
                  break;
              }
            }
            catch (e) {
              console.error(e);
            }
          }
        }
        if (s.length === 1) {
          outEl.value = s[0].value.toString(base);
        }
        else {
          outEl.value = '';
        }
      }
    };

    let baseChanged = event => {
      base = parseInt(event.target.value);
      localStorage.setItem('base', base);
      formulaChanged();
    };

    let main = () => {
      inEl = document.getElementById('input');
      inEl.addEventListener('input', formulaChanged);
      outEl = document.getElementById('output');
      msgEl = document.getElementById('msg');
      baseFormEl = document.getElementById('base-form');
      baseFormEl.addEventListener('change', baseChanged);
      document.getElementById(`base-${base}`).checked = true;
    }

    window.addEventListener('load', main);
  })(window);
</script>

<body>
  <div class="app">
    <h1>Binary Calculator</h1>
    <div class="container"><textarea id="input"
        placeholder="type formula here, e.g. '1001 ^ 1111' to XOR two values"></textarea></div>
        <div class="container">
            <form id="base-form">
              <input id="base-2" name="base" type="radio" value="2"></option>
              <label for="base-2">binary</label>
              <input id="base-8" name="base" type="radio" value="8"></option>
              <label for="base-8">octal</label>
              <input id="base-10" name="base" type="radio" value="10"></option>
              <label for="base-10">decimal</label>
              <input id="base-16" name="base" type="radio" value="16"></option>
              <label for="base-16">hexadecimal</label>
            </form>
          </div>
          <div class="container"><textarea id="output" readonly placeholder="result will be displayed here"></textarea></div>
    <div class="container"><span id="msg"></span></div>
  </div>
</body>

</html>