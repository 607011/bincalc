<html>

<head>
  <title>Arbitrary Precision Calculator</title>
</head>
<!--
    Arbitrary Precision Calculator.
    Copyright (C) 2019 Oliver Lau <ola@ct.de>, Heise Medien GmbH & Co. KG

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<style type="text/css">
  * {
    margin: 0;
    padding: 0;
  }

  html,
  body {
    background-color: #e9e7de;
    color: #222;
    font-family: 'Courier New', Courier, monospace;
    font-size: 12pt;
  }

  h1 {
    font-size: 18pt;
  }

  a {
    color: #555;
    font-weight: bold;
    text-decoration: none;
  }

  a:visited {
    color: #666;
  }

  a:hover {
    text-decoration: underline;
  }

  .app {
    padding: 5pt;
  }

  p {
    margin: 5pt auto;
  }

  #msg {
    min-height: 5ex;
    display: inline-block;
  }

  textarea {
    background-color: white;
    color: black;
    font-family: "Courier New", Courier, monospace;
    font-size: 12pt;
    padding: 4pt;
    width: 100%;
    height: 50pt;
  }
</style>
<script type="text/javascript">
  (function (window) {
    'use strict';
    let inEl = null;
    let outEl = null;
    let msgEl = null;
    let baseFormEl = null;
    let values = [];
    let ops = [];
    let base = localStorage.getItem('base') || 2;
    const Padding = (function (length) {
      let padding = '';
      for (let i = 0; i < length; ++i) {
        padding += '0';
      }
      return padding;
    })(512);

    Array.prototype.peek = function () { return this[this.length - 1]; };

    class Token {
      constructor(type, value) {
        this._type = type;
        this._value = value;
      }

      get type() {
        return this._type;
      }

      get value() {
        return this._value;
      }

      set type(t) {
        this._type = t;
      }

      set value(v) {
        this._value = v;
      }

      get precedence() {
        return Token.Operator[this.value].prec;
      }

      get associativity() {
        return Token.Operator[this.value].assoc;
      }
    }

    Token.Type = (function (types) {
      let obj = {};
      for (let i in types) {
        obj[types[i]] = +i + 1;
      }
      return obj;
    })(['Literal', 'Operator', 'Variable', 'LeftParenthesis', 'RightParenthesis']);

    Token.BasePrefix = {
      2: '0b',
      8: '0o',
      10: '',
      16: '0x',
    };

    Token.Types = [
      { regex: /^(~=|~|&=|\^=|\/=|\^|\&|\||\+|\-|\*\*|\*|\/|%|==|!=|<<|>>|<=|>=|<|>|=)/, type: Token.Type.Operator, name: 'operator' },
      { regex: /^(\()/, type: Token.Type.LeftParenthesis, name: 'left parenthesis' },
      { regex: /^(\))/, type: Token.Type.RightParenthesis, name: 'right parenthesis' },
      { regex: /^b([01]+)/, type: Token.Type.Literal, base: 2, name: 'binary' },
      { regex: /^o([0-7]+)/, type: Token.Type.Literal, base: 8, name: 'octal' },
      { regex: /^([0-9]+)/, type: Token.Type.Literal, base: 10, name: 'decimal' },
      { regex: /^x([0-9a-fA-F]+)/, type: Token.Type.Literal, base: 16, name: 'hexadecimal' },
      { regex: /^([a-zA-Z_]+)/, type: Token.Type.Variable, name: 'variable' },
    ];

    const LEFT = -1;
    const RIGHT = 1;

    // see https://en.cppreference.com/w/cpp/language/operator_precedence
    Token.Operator = {
      '-': {
        prec: -3,
        assoc: RIGHT,
      },
      '~': {
        prec: -3,
        assoc: RIGHT,
      },
      '**': {
        prec: -4,
        assoc: RIGHT,
      },
      '*': {
        prec: -5,
        assoc: LEFT,
      },
      '/': {
        prec: -5,
        assoc: LEFT,
      },
      '%': {
        prec: -5,
        assoc: LEFT,
      },
      '+': {
        prec: -6,
        assoc: LEFT,
      },
      '-': {
        prec: -6,
        assoc: LEFT,
      },
      '<<': {
        prec: -7,
        assoc: LEFT,
      },
      '>>': {
        prec: -7,
        assoc: LEFT,
      },
      '<': {
        prec: -9,
        assoc: LEFT,
      },
      '>': {
        prec: -9,
        assoc: LEFT,
      },
      '==': {
        prec: -9,
        assoc: LEFT,
      },
      '!=': {
        prec: -9,
        assoc: LEFT,
      },
      '<=': {
        prec: -9,
        assoc: LEFT,
      },
      '>=': {
        prec: -9,
        assoc: LEFT,
      },
      '&': {
        prec: -11,
        assoc: LEFT,
      },
      '^': {
        prec: -12,
        assoc: LEFT,
      },
      '|': {
        prec: -13,
        assoc: LEFT,
      },
      '=': {
        prec: -16,
        assoc: RIGHT,
      }
    };

    let tokenize = str => {
      let expr = str.replace(/\s+/g, '');
      let tokens = [];
      while (expr.length > 0) {
        let found = false;
        for (let i = 0; i < Token.Types.length && !found; ++i) {
          let t = Token.Types[i];
          let m = expr.match(t.regex);
          if (m && m.length > 0) {
            let symbol = m[1];
            let len = m[0].length;
            let value;
            switch (t.type) {
              case Token.Type.Literal:
                try {
                  value = BigInt(Token.BasePrefix[t.base] + symbol);
                }
                catch (e) {
                  console.error(e);
                }
                break;
              default:
                value = symbol;
                break;
            }
            tokens.push(new Token(t.type, value));
            expr = expr.substring(len);
            found = true;
          }
        }
        if (!found) {
          return { error: `invalid expression: ${str}` };
        }
      }
      return { tokens: tokens };
    }

    let shuntingYard = tokens => {
      let ops = [];
      let queue = [];
      for (const token of tokens) {
        switch (token.type) {
          case Token.Type.Literal:
          // fall-through
          case Token.Type.Variable:
            queue.push(token);
            break;
          case Token.Type.Operator:
            while (ops.peek() &&
              (ops.peek().type !== Token.Type.LeftParenthesis)
              &&
              (
                (ops.peek().precedence > token.precedence)
                ||
                (ops.peek().precedence === token.precedence && ops.peek().associativity === LEFT)
              )
            ) {
              queue.push(ops.pop());
            }
            ops.push(token);
            break;
          case Token.Type.LeftParenthesis:
            ops.push(token);
            break;
          case Token.Type.RightParenthesis:
            while (ops.peek() && ops.peek().type !== Token.Type.LeftParenthesis) {
              queue.push(ops.pop());
            }
            if (ops.peek().type === Token.Type.LeftParenthesis) {
              ops.pop();
            }
            break;
          default:
            break;
        }
      }
      while (ops.length > 0) {
        queue.push(ops.pop());
      }
      return queue;
    }

    let newLiteral = value => {
      return new Token(Token.Type.Literal, value);
    }

    let formulaChanged = event => {
      let result = tokenize(inEl.value);
      if (result.error) {
        msgEl.innerText = result.error;
        return;
      }
      else {
        msgEl.innerText = '';
      }
      if (result.tokens) {
        let tokens = shuntingYard(result.tokens);
        let s = [];
        for (const t of tokens) {
          if (t.type === Token.Type.Literal) {
            s.push(t);
          }
          else if (t.type === Token.Type.Variable) {
            s.push(t); // XXX
          }
          else {
            let b = s.pop();
            let a = s.pop();
            if (a instanceof Token && b instanceof Token) {
              try {
                switch (t.value) {
                  case '+':
                    s.push(newLiteral(a.value + b.value));
                    break;
                  case '-':
                    s.push(newLiteral(a.value - b.value));
                    break;
                  case '*':
                    s.push(newLiteral(a.value * b.value));
                    break;
                  case '**':
                    s.push(newLiteral(a.value ** b.value));
                    break;
                  case '/':
                    s.push(newLiteral(a.value / b.value));
                    break;
                  case '%':
                    s.push(newLiteral(a.value % b.value));
                    break;
                  case '^':
                    s.push(newLiteral(a.value ^ b.value));
                    break;
                  case '|':
                    s.push(newLiteral(a.value | b.value));
                    break;
                  case '&':
                    s.push(newLiteral(a.value & b.value));
                    break;
                  case '<<':
                    s.push(newLiteral(a.value << b.value));
                    break;
                  case '>>':
                    s.push(newLiteral(a.value >> b.value));
                    break;
                  case '<':
                    s.push(newLiteral(a.value < b.value ? 1 : 0));
                    break;
                  case '>':
                    s.push(newLiteral(a.value > b.value ? 1 : 0));
                    break;
                  case '<=':
                    s.push(newLiteral(a.value <= b.value ? 1 : 0));
                    break;
                  case '>=':
                    s.push(newLiteral(a.value >= b.value ? 1 : 0));
                    break;
                  case '==':
                    s.push(newLiteral(a.value == b.value ? 1 : 0));
                    break;
                  case '!=':
                    s.push(newLiteral(a.value != b.value ? 1 : 0));
                    break;
                }
              }
              catch (e) {
                console.error(e);
              }
            }
            else if (b instanceof Token) {
              switch (t.value) {
                case '-':
                  s.push(newLiteral(-b.value));
                  break;
                case '~':
                  s.push(newLiteral(~b.value));
                  break;
              }
            }
          }
        }
        if (s.length === 1) {
          outEl.value = s[0].value.toString(base);
          msgEl.value = '';
        }
        else {
          outEl.value = '';
          msgEl.value = 'invalid expression';
        }
      }
    };

    let baseChanged = event => {
      base = parseInt(event.target.value);
      localStorage.setItem('base', base);
      formulaChanged();
    };

    let main = () => {
      inEl = document.getElementById('input');
      inEl.addEventListener('input', formulaChanged);
      outEl = document.getElementById('output');
      msgEl = document.getElementById('msg');
      baseFormEl = document.getElementById('base-form');
      baseFormEl.addEventListener('change', baseChanged);
      document.getElementById(`base-${base}`).checked = true;
    }

    window.addEventListener('load', main);
  })(window);
</script>

<body>
  <div class="app">
    <h1>Arbitrary Precision Calculator</h1>
    <p><textarea id="input"
        placeholder="type formula here, e.g. 'b1001 ^ x0f' to XOR a binary with a hexadecimal value"></textarea></p>
    <p><textarea id="output" readonly placeholder="result will be displayed here"></textarea></p>
    <p>
      <form id="base-form">
        <input id="base-2" name="base" type="radio" value="2"></option>
        <label for="base-2">binary</label>
        <input id="base-8" name="base" type="radio" value="8"></option>
        <label for="base-8">octal</label>
        <input id="base-10" name="base" type="radio" value="10"></option>
        <label for="base-10">decimal</label>
        <input id="base-16" name="base" type="radio" value="16"></option>
        <label for="base-16">hexadecimal</label>
      </form>
    </p>
    <p><span id="msg"></span></p>
    <hr style="margin-top: 29pt; margin-bottom: 7pt;" />
    <dp><span style="font-size: smaller">
        Arbitrary Precision Calculator v0.1.1 &ndash;
        Copyright &copy; 2019 <a href="mailto:ola@ct.de">Oliver Lau</a>, <a
          href="https://www.heise-gruppe.de/heise-medien.html" target="_blank">Heise Medien GmbH & Co. KG</a>, <a
          href="https://ct.de/" target="_blank">Redaktion c't</a></span></p>
      <p><span style="font-size: smaller"><em>(Uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank">BigInt</a>, therefore Chrome 67, Firefox 68 or Opera 54 are needed.)</em></span></p>
  </div>
</body>

</html>