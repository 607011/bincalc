<html>

<head>
  <title>Arbitrary Precision Calculator</title>
</head>
<!--
    Arbitrary Precision Calculator.
    Copyright (C) 2019 Oliver Lau <ola@ct.de>, Heise Medien GmbH & Co. KG

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<style type="text/css">
  * {
    margin: 0;
    padding: 0;
  }

  html,
  body {
    background-color: #e9e7de;
    color: #222;
    font-family: 'Courier New', Courier, monospace;
    font-size: 12pt;
  }

  h1 {
    font-size: 18pt;
  }

  a {
    color: #555;
    font-weight: bold;
    text-decoration: none;
  }

  a:visited {
    color: #666;
  }

  a:hover {
    text-decoration: underline;
  }

  .app {
    padding: 5pt;
  }

  p {
    margin: 5pt auto;
  }

  #msg {
    min-height: 5ex;
    display: inline-block;
  }

  .hide {
    animation-delay: 1s;
    animation-duration: 250ms;
    animation-name: hide;
    animation-timing-function: ease;
    animation-fill-mode: forwards;
  }

  @keyframes hide {
    from {
      opacity: 1;
    }
    to {
      opacity: 0;
    }
  }

  textarea {
    background-color: white;
    color: black;
    font-family: 'Courier New', Courier, monospace;
    font-size: 12pt;
    padding: 4pt;
    width: 100%;
    height: 50pt;
  }
</style>
<script type="text/javascript">
  (function (window) {
    'use strict';
    const Padding = (function (length) {
      let padding = '';
      for (let i = 0; i < length; ++i) {
        padding += '0';
      }
      return padding;
    })(512);

    let inEl = null;
    let outEl = null;
    let msgEl = null;
    let baseFormEl = null;
    let values = [];
    let ops = [];
    let base = localStorage.getItem('base') || 2;

    class Stack {
      constructor() {
        this._stack = [];
        this._nextIndex = 0;
      }
      push(value) {
        this._stack.push(value);
      }
      pop() {
        return this._stack.pop();
      }
      get top() {
        return this._stack[this._stack.length - 1];
      }
      get length() {
        return this._stack.length;
      }
      [Symbol.iterator]() {
        return {
          next: () => {
            if (this._nextIndex < this.length) {
              return { value: this._stack[this._nextIndex++], done: false };
            }
            this._nextIndex = 0;
            return { done: true };
          }
        }
      }
    }

    class Token {
      constructor(type, value) {
        this._type = type;
        this._value = value;
      }
      get type() {
        return this._type;
      }
      get value() {
        return this._value;
      }
      set type(t) {
        this._type = t;
      }
      set value(v) {
        this._value = v;
      }
      get precedence() {
        return Token.Operator[this.value].prec;
      }
      get associativity() {
        return Token.Operator[this.value].assoc;
      }
    }

    Token.Type = (function (types) {
      let obj = {};
      for (let i in types) {
        obj[types[i]] = +i + 1;
      }
      return obj;
    })(['Literal', 'Operator', 'Variable', 'LeftParenthesis', 'RightParenthesis']);

    Token.BasePrefix = { 2: '0b', 8: '0o', 10: '', 16: '0x' };

    Token.Types = [
      { regex: /^(~=|~|&=|\^=|\/=|\^|\&|\||\+|\-|\*\*|\*|\/|%|==|!=|<<|>>|<=|>=|<|>|=)/, type: Token.Type.Operator, name: 'operator' },
      { regex: /^(\()/, type: Token.Type.LeftParenthesis, name: 'left parenthesis' },
      { regex: /^(\))/, type: Token.Type.RightParenthesis, name: 'right parenthesis' },
      { regex: /^b([01]+)/, type: Token.Type.Literal, base: 2, name: 'binary' },
      { regex: /^o([0-7]+)/, type: Token.Type.Literal, base: 8, name: 'octal' },
      { regex: /^([0-9]+)/, type: Token.Type.Literal, base: 10, name: 'decimal' },
      { regex: /^x([0-9a-fA-F]+)/, type: Token.Type.Literal, base: 16, name: 'hexadecimal' },
      { regex: /^([a-zA-Z_]+)/, type: Token.Type.Variable, name: 'variable' },
    ];

    const LEFT = 'left';
    const RIGHT = 'right';

    let tokenize = str => {
      let expr = str.replace(/\s+/g, '');
      let tokens = [];
      while (expr.length > 0) {
        let found = false;
        for (let i = 0; i < Token.Types.length && !found; ++i) {
          let t = Token.Types[i];
          let m = expr.match(t.regex);
          if (m && m.length > 0) {
            let symbol = m[1];
            let len = m[0].length;
            let value;
            switch (t.type) {
              case Token.Type.Literal:
                try {
                  value = BigInt(Token.BasePrefix[t.base] + symbol);
                }
                catch (e) {
                  console.error(e);
                }
                break;
              default:
                value = symbol;
                break;
            }
            tokens.push(new Token(t.type, value));
            expr = expr.substring(len);
            found = true;
          }
        }
        if (!found) {
          return { error: `invalid expression: ${str}` };
        }
      }
      return { tokens: tokens };
    }

    let shuntingYard = tokens => {
      let ops = new Stack();
      let queue = new Stack();
      for (const token of tokens) {
        switch (token.type) {
          case Token.Type.Literal:
          // fall-through
          case Token.Type.Variable:
            queue.push(token);
            break;
          case Token.Type.Operator:
            while (ops.top &&
              (ops.top.type !== Token.Type.LeftParenthesis)
              &&
              (
                (ops.top.precedence > token.precedence)
                ||
                (ops.top.precedence === token.precedence && ops.top.associativity === LEFT)
              )
            ) {
              queue.push(ops.pop());
            }
            ops.push(token);
            break;
          case Token.Type.LeftParenthesis:
            ops.push(token);
            break;
          case Token.Type.RightParenthesis:
            while (ops.top && ops.top.type !== Token.Type.LeftParenthesis) {
              queue.push(ops.pop());
            }
            if (ops.top.type === Token.Type.LeftParenthesis) {
              ops.pop();
            }
            break;
          default:
            break;
        }
      }
      while (ops.length > 0) {
        queue.push(ops.pop());
      }
      return queue;
    }

    let newLiteral = value => {
      return new Token(Token.Type.Literal, value);
    }

    let calculate = expr => {
      let result = tokenize(expr);
      if (result.error) {
        return result;
      }
      if (result.tokens) {
        let s = new Stack();
        let tokens = shuntingYard(result.tokens);
        for (const t of tokens) {
          if (t.type === Token.Type.Literal) {
            s.push(t);
          }
          else if (t.type === Token.Type.Variable) {
            s.push(t); // XXX
          }
          else {
            let b = s.pop();
            let a = s.pop();
            if (a instanceof Token && b instanceof Token) {
              try {
                switch (t.value) {
                  case '+':
                    s.push(newLiteral(a.value + b.value));
                    break;
                  case '-':
                    s.push(newLiteral(a.value - b.value));
                    break;
                  case '*':
                    s.push(newLiteral(a.value * b.value));
                    break;
                  case '**':
                    s.push(newLiteral(a.value ** b.value));
                    break;
                  case '/':
                    s.push(newLiteral(a.value / b.value));
                    break;
                  case '%':
                    s.push(newLiteral(a.value % b.value));
                    break;
                  case '^':
                    s.push(newLiteral(a.value ^ b.value));
                    break;
                  case '|':
                    s.push(newLiteral(a.value | b.value));
                    break;
                  case '&':
                    s.push(newLiteral(a.value & b.value));
                    break;
                  case '<<':
                    s.push(newLiteral(a.value << b.value));
                    break;
                  case '>>':
                    s.push(newLiteral(a.value >> b.value));
                    break;
                  case '<':
                    s.push(newLiteral(a.value < b.value ? 1n : 0n));
                    break;
                  case '>':
                    s.push(newLiteral(a.value > b.value ? 1n : 0n));
                    break;
                  case '<=':
                    s.push(newLiteral(a.value <= b.value ? 1n : 0n));
                    break;
                  case '>=':
                    s.push(newLiteral(a.value >= b.value ? 1n : 0n));
                    break;
                  case '==':
                    s.push(newLiteral(a.value == b.value ? 1n : 0n));
                    break;
                  case '!=':
                    s.push(newLiteral(a.value != b.value ? 1n : 0n));
                    break;
                }
              }
              catch (e) {
                console.error(e);
              }
            }
            else if (b instanceof Token) {
              switch (t.value) {
                case '-':
                  s.push(newLiteral(-b.value));
                  break;
                case '~':
                  s.push(newLiteral(~b.value));
                  break;
              }
            }
          }
        }
        if (s.length === 1) {
          return { result: s.top.value.toString(base) };
        }
      }
      return { error: 'invalid expression' };
    };

    let formulaChanged = event => {
      let t0 = performance.now();
      msgEl.innerHTML = 'Calculating&nbsp;&hellip;';
      msgEl.classList.remove('hide');
      setTimeout(() => {
        let results = [];
        let expressions = inEl.value.split('\n');
        let errorFound = false;
        for (const expr of expressions) {
          const result = calculate(expr);
          if (result.result) {
            results.push(result);
          }
          else {
            msgEl.innerHTML = result.error;
            errorFound = true;
            break;
          }
        }
        if (!errorFound) {
          let dt = 1e-3 * (performance.now() - t0);
          msgEl.innerHTML = `Calculation took ${dt.toFixed(4)} seconds`;
          msgEl.classList.add('hide');
          if (results.length > 0) {
            outEl.value = results.map(r => r.result).join('\n');
          }
        }
      }, 0);
    };

    let baseChanged = event => {
      base = parseInt(event.target.value);
      localStorage.setItem('base', base);
      formulaChanged();
    };

    let main = () => {
      inEl = document.getElementById('input');
      inEl.addEventListener('input', formulaChanged);
      outEl = document.getElementById('output');
      msgEl = document.getElementById('msg');
      baseFormEl = document.getElementById('base-form');
      baseFormEl.addEventListener('change', baseChanged);
      document.getElementById(`base-${base}`).checked = true;
    }

    let loadResources = () => {
      fetch('token.json')
        .then(res => res.json())
        .then(out => {
          Token.Operator = out;
        })
        .catch(err => { throw err });
    };

    loadResources();
    window.addEventListener('load', main);
  })(window);
</script>

<body>
  <div class="app">
    <h1>Arbitrary Precision Calculator</h1>
    <p><textarea id="input"
        placeholder="type formula here, e.g. 'b1001 ^ x0f' to XOR a binary with a hexadecimal value"></textarea></p>
    <p><textarea id="output" readonly placeholder="result will be displayed here"></textarea></p>
    <p>
      <form id="base-form">
        <input id="base-2" name="base" type="radio" value="2"></option>
        <label for="base-2">binary</label>
        <input id="base-8" name="base" type="radio" value="8"></option>
        <label for="base-8">octal</label>
        <input id="base-10" name="base" type="radio" value="10"></option>
        <label for="base-10">decimal</label>
        <input id="base-16" name="base" type="radio" value="16"></option>
        <label for="base-16">hexadecimal</label>
      </form>
    </p>
    <p><span id="msg"></span></p>
    <hr style="margin-top: 29pt; margin-bottom: 7pt;" />
    <dp><span style="font-size: smaller">
        <strong>Arbitrary Precision Calculator</strong> v0.1.1 &ndash;
        Copyright &copy; 2019 <a href="mailto:ola@ct.de">Oliver Lau</a>, <a
          href="https://www.heise-gruppe.de/heise-medien.html" target="_blank">Heise Medien GmbH & Co. KG</a>, <a
          href="https://ct.de/" target="_blank">Redaktion c't</a></span></p>
      <p><span style="font-size: smaller"><em>(Uses <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"
              target="_blank">BigInt</a>, therefore Chrome &ge;67, Firefox &ge;68 or Opera &ge;54 are needed.)</em></span></p>
  </div>
</body>

</html>