<html>

<head>
  <title>Arbitrary Precision Calculator</title>
</head>
<!--
    Arbitrary Precision Calculator.
    Copyright (C) 2019 Oliver Lau <ola@ct.de>, Heise Medien GmbH & Co. KG

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<style type="text/css">
  * {
    margin: 0;
    padding: 0;
  }

  html,
  body {
    background-color: #e9e7de;
    color: #222;
    font-family: 'Courier New', Courier, monospace;
    font-size: 12pt;
  }

  h1 {
    font-size: 18pt;
  }

  a {
    color: #555;
    font-weight: bold;
    text-decoration: none;
  }

  a:visited {
    color: #666;
  }

  a:hover {
    text-decoration: underline;
  }

  .app {
    padding: 5pt;
  }

  p {
    margin: 5pt auto;
  }

  #msg {
    min-height: 5ex;
    display: inline-block;
    font-weight: bold;
  }

  .error {
    color: rgb(223, 53, 53);
  }

  .hide {
    animation-delay: 1s;
    animation-duration: 250ms;
    animation-name: hide;
    animation-timing-function: ease;
    animation-fill-mode: forwards;
  }

  @keyframes hide {
    from {
      opacity: 1;
    }

    to {
      opacity: 0;
    }
  }

  textarea {
    background-color: white;
    color: black;
    font-family: 'Courier New', Courier, monospace;
    font-size: 12pt;
    padding: 4pt;
    width: 100%;
    height: 20%;
  }
</style>
<script type="text/javascript">
  (function (window) {
    'use strict';
    const Padding = (function (length) {
      let padding = '';
      for (let i = 0; i < length; ++i) {
        padding += '0';
      }
      return padding;
    })(512);

    let inEl = null;
    let outEl = null;
    let msgEl = null;
    let baseFormEl = null;
    let base = localStorage.getItem('base') || 2;
    let variables = {};

    Array.prototype.last = () => this[this.length - 1];

    class Stack {
      constructor() {
        this._stack = [];
        this._nextIndex = 0;
      }
      push(value) {
        this._stack.push(value);
      }
      pop() {
        return this._stack.pop();
      }
      get top() {
        return this._stack[this._stack.length - 1];
      }
      set top(v) {
        this._stack[this._stack.length - 1] = v;
      }
      get length() {
        return this._stack.length;
      }
      [Symbol.iterator]() {
        return {
          next: () => {
            if (this._nextIndex < this.length) {
              return { value: this._stack[this._nextIndex++], done: false };
            }
            this._nextIndex = 0;
            return { done: true };
          }
        }
      }
    }

    class Token {
      constructor(type, value) {
        this._type = type;
        this._value = value;
      }
      get type() {
        return this._type;
      }
      get value() {
        return this._value;
      }
      set type(t) {
        this._type = t;
      }
      set value(v) {
        this._value = v;
      }
      get precedence() {
        return Token.Operator[this.value].prec;
      }
      get associativity() {
        return Token.Operator[this.value].assoc;
      }
    }

    Token.Type = (function (types) {
      let obj = {};
      for (let i in types) {
        obj[types[i]] = +i + 1;
      }
      return obj;
    })(['Literal', 'Operator', 'Variable', 'LeftParenthesis', 'RightParenthesis']);

    Token.BasePrefix = { 2: '0b', 8: '0o', 10: '', 16: '0x' };

    Token.Operators = ['~=', '~', '&=', '^=', '/=', '%=', '+=', '-=', '<<=', '>>=', '^', '&', '|', '+', '-', '**', '*', '/', '%', '<<', '>>', '==', '!=', '<=', '>=', '>', '<', '='];

    Token.Symbols = {
      UnaryMinus: '\u{2212}',
    };

    Token.Types = [
      { regex: new RegExp(`^(${Token.Operators.map(o => o.replace(/[\|\-\/\*\+\^\$]/g, '\\$&')).join('|')})`), type: Token.Type.Operator, name: 'operator' },
      { regex: /^b([01]+)/, type: Token.Type.Literal, base: 2, name: 'binary' },
      { regex: /^o([0-7]+)/, type: Token.Type.Literal, base: 8, name: 'octal' },
      { regex: /^([0-9]+)/, type: Token.Type.Literal, base: 10, name: 'decimal' },
      { regex: /^x([0-9a-fA-F]+)/, type: Token.Type.Literal, base: 16, name: 'hexadecimal' },
      { regex: /^([a-zA-Z_]+)/, type: Token.Type.Variable, name: 'variable' },
      { regex: /^(\()/, type: Token.Type.LeftParenthesis, name: 'left parenthesis' },
      { regex: /^(\))/, type: Token.Type.RightParenthesis, name: 'right parenthesis' },
    ];

    const LEFT = 'left';
    const RIGHT = 'right';

    let tokenize = str => {
      let expr = str.replace(/\s+/gm, '');
      let tokens = [];
      while (expr.length > 0) {
        let found = false;
        for (let i = 0; i < Token.Types.length && !found; ++i) {
          let t = Token.Types[i];
          let m = expr.match(t.regex);
          if (m && m.length > 0) {
            let symbol = m[1];
            let len = m[0].length;
            let value;
            switch (t.type) {
              case Token.Type.Literal:
                try {
                  value = BigInt(Token.BasePrefix[t.base] + symbol);
                }
                catch (e) {
                  console.error(e);
                }
                break;
              default:
                if (symbol === '-' && (tokens.length === 0 || tokens.last === Token.Type.LeftParenthesis || (tokens.last in Token.Operators))) {
                  symbol = Token.Symbols.UnaryMinus;
                }
                value = symbol;
                break;
            }
            tokens.push(new Token(t.type, value));
            expr = expr.substring(len);
            found = true;
          }
        }
        if (!found) {
          return { error: `invalid expression: ${str}` };
        }
      }
      return { tokens: tokens };
    }

    let shuntingYard = tokens => {
      let ops = new Stack();
      let queue = new Stack();
      for (const token of tokens) {
        switch (token.type) {
          case Token.Type.Literal:
          // fall-through
          case Token.Type.Variable:
            queue.push(token);
            break;
          case Token.Type.Operator:
            while (ops.top &&
              (ops.top.type !== Token.Type.LeftParenthesis)
              &&
              (
                (ops.top.precedence > token.precedence)
                ||
                (ops.top.precedence === token.precedence && ops.top.associativity === LEFT)
              )
            ) {
              queue.push(ops.pop());
            }
            ops.push(token);
            break;
          case Token.Type.LeftParenthesis:
            ops.push(token);
            break;
          case Token.Type.RightParenthesis:
            while (ops.top && ops.top.type !== Token.Type.LeftParenthesis) {
              queue.push(ops.pop());
            }
            if (ops.top.type === Token.Type.LeftParenthesis) {
              ops.pop();
            }
            break;
          default:
            break;
        }
      }
      while (ops.length > 0) {
        queue.push(ops.pop());
      }
      return queue;
    }

    let newLiteral = value => {
      return new Token(Token.Type.Literal, value);
    }

    let calculate = expr => {
      const result = tokenize(expr);
      if (result.error) {
        return result;
      }
      console.log('tokens =', result.tokens);
      if (result.tokens) {
        let s = new Stack();
        const tokens = shuntingYard(result.tokens);
        console.log('RPN =', tokens._stack);
        for (const t of tokens) {
          if (t.type === Token.Type.Literal || t.type === Token.Type.Variable) {
            s.push(t);
          }
          else {
            if (t.type === Token.Type.Operator && t.value === Token.Symbols.UnaryMinus) {
              s.top.value = -s.top.value;
            }
            else {
              const bToken = s.pop();
              const aToken = s.pop();
              if (aToken instanceof Token && bToken instanceof Token) {
                let a = (aToken.type === Token.Type.Literal)
                  ? aToken.value
                  : variables[aToken.value];
                let b = (bToken.type === Token.Type.Literal)
                  ? bToken.value
                  : variables[bToken.value];
                try {
                  switch (t.value) {
                    case '=': variables[aToken.value] = b; break;
                    case '+': s.push(newLiteral(a + b)); break;
                    case '-': s.push(newLiteral(a - b)); break;
                    case '*': s.push(newLiteral(a * b)); break;
                    case '**': s.push(newLiteral(a ** b)); break;
                    case '/': s.push(newLiteral(a / b)); break;
                    case '%': s.push(newLiteral(a % b)); break;
                    case '^': s.push(newLiteral(a ^ b)); break;
                    case '|': s.push(newLiteral(a | b)); break;
                    case '&': s.push(newLiteral(a & b)); break;
                    case '<<': s.push(newLiteral(a << b)); break;
                    case '>>': s.push(newLiteral(a >> b)); break;
                    case '<': s.push(newLiteral(a < b ? 1n : 0n)); break;
                    case '>': s.push(newLiteral(a > b ? 1n : 0n)); break;
                    case '<=': s.push(newLiteral(a <= b ? 1n : 0n)); break;
                    case '>=': s.push(newLiteral(a >= b ? 1n : 0n)); break;
                    case '==': s.push(newLiteral(a == b ? 1n : 0n)); break;
                    case '!=': s.push(newLiteral(a != b ? 1n : 0n)); break;
                  }
                }
                catch (e) {
                  console.error(e);
                }
              }
              else if (bToken instanceof Token) {
                console.log(s, bToken);
              }
            }
          }
        }
        if (s.length === 1) {
          if (s.top.type === Token.Type.Variable) {
            if (variables.hasOwnProperty(s.top.value)) {
              return { result: variables[s.top.value].toString(base) };
            }
            else {
              return { error: `undefined variable '${s.top.value}'`}
            }
          }
          return { result: s.top.value.toString(base) };
        }
        else {
          return { result: undefined };
        }
      }
      return { error: 'invalid expression' };
    };

    let formulaChanged = event => {
      const t0 = performance.now();
      msgEl.innerHTML = 'Calculating&nbsp;&hellip;';
      msgEl.classList.remove('hide');
      msgEl.classList.remove('error');
      let results = [];
      const expressions = inEl.value.split('\n');
      let errorFound = false;
      for (const expr of expressions) {
        const {result, error} = calculate(expr);
        if (error) {
          msgEl.innerHTML = error;
          msgEl.classList.add('error');
          errorFound = true;
          break;
        }
        else if (result) {
          results.push(result);
        }
      }
      if (!errorFound) {
        const dt = 1e-3 * (performance.now() - t0);
        msgEl.innerHTML = `Calculation took ${dt.toFixed(4)} seconds`;
        msgEl.classList.add('hide');
        if (results.length > 0) {
          outEl.value = results.join('\n');
        }
      }
    };

    let baseChanged = event => {
      base = parseInt(event.target.value);
      localStorage.setItem('base', base);
      formulaChanged();
    };

    let main = operatorMap => {
      Token.Operator = operatorMap;
      inEl = document.getElementById('input');
      inEl.addEventListener('input', formulaChanged);
      outEl = document.getElementById('output');
      msgEl = document.getElementById('msg');
      baseFormEl = document.getElementById('base-form');
      baseFormEl.addEventListener('change', baseChanged);
      document.getElementById(`base-${base}`).checked = true;
    }

    let init = () => {
      fetch('token.json')
        .then(res => res.json())
        .then(operators => {
          main(operators);
        })
        .catch(err => { throw err });
    };

    window.addEventListener('load', init);
  })(window);
</script>

<body>
  <div class="app">
    <h1>Arbitrary Precision Calculator</h1>
    <p><textarea id="input"
        placeholder="type formula here, e.g. 'b1001 ^ x0f' to XOR a binary with a hexadecimal value"></textarea></p>
    <p><textarea id="output" readonly placeholder="result will be displayed here"></textarea></p>
    <p>
      <form id="base-form">
        <input id="base-2" name="base" type="radio" value="2"></option>
        <label for="base-2">binary</label>
        <input id="base-8" name="base" type="radio" value="8"></option>
        <label for="base-8">octal</label>
        <input id="base-10" name="base" type="radio" value="10"></option>
        <label for="base-10">decimal</label>
        <input id="base-16" name="base" type="radio" value="16"></option>
        <label for="base-16">hexadecimal</label>
      </form>
    </p>
    <p><span id="msg"></span></p>
    <hr style="margin-top: 29pt; margin-bottom: 7pt;" />
    <dp><span style="font-size: smaller">
        <strong>Arbitrary Precision Calculator</strong> v0.3-EXPERIMENTAL &ndash;
        Copyright &copy; 2019 <a href="mailto:ola@ct.de">Oliver Lau</a>, <a
          href="https://www.heise-gruppe.de/heise-medien.html" target="_blank">Heise Medien GmbH & Co. KG</a>, <a
          href="https://ct.de/" target="_blank">Redaktion c't</a></span></p>
      <p><span style="font-size: smaller"><em>(Uses <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"
              target="_blank">BigInt</a>, therefore Chrome &ge;67, Firefox &ge;68 or Opera &ge;54 are
            needed.)</em></span></p>
  </div>
</body>

</html>